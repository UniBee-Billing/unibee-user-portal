import { Dayjs } from 'dayjs'
import { Currency } from 'dinero.js'

export enum CreditType {
  MAIN = 1, // main, rechargeable
  PROMO_CREDIT = 2 // promo credit account
}
export type TPromoAccount = {
  id: number
  userId: number
  type: CreditType
  currency: string
  amount: number // current balance
  exchangeRate: number
  totalIncrementAmount: number // total added
  totalDecrementAmount: number // total used
  currencyAmount: number
  payoutEnable: boolean | 1 | 0
  rechargeEnable: boolean | 1 | 0
  createTime: number
}
export enum AccountType {
  PERSONAL = 1,
  BUSINESS = 2
}
interface IProfile {
  address: string
  countryName: string
  countryCode: string
  companyName: string
  email: string
  facebook: string
  firstName: string
  lastName: string
  id: number | null
  externalUserId: string
  phone: string
  type: AccountType
  paymentMethod: string // for card payment, this is the stripe paymentId, used for auto recurring payment
  gatewayId?: number // after a successful payment, the payment gateway is saved as default. This is null for newly registered user.
  gateway?: TGateway // ditto.
  promoCreditAccounts?: TPromoAccount[]
  linkedIn: string
  telegram: string
  tikTok: string
  vATNumber: string
  registrationNumber: string
  weChat: string
  whatsAPP: string
  otherSocialInfo: string
  token: string
  language: string // en | ru | cn | vi | pt,      English | Russian | Chinese | Vietnamese | Portuguese
}

export type TGatewayExRate = {
  localId?: string
  from_currency: string
  to_currency: string
  exchange_rate: number
}
export type TGateway = {
  IsSetupFinished: boolean // true: this gateway is ready for use
  gatewayId: number // == 0: totally new gateway, admin hasn't configured anything yet.
  // as long as admin has configured something, even just the displayName or icons, gatewayId will become non-zero, but this doesn't mean this gateway is ready for use.
  id?: string // to make configItem sortable, SortableItem component needs an unique id field. gatewayConfig has gatewayId, but it's 0 if not configured,
  name: string // e.g., Stripe
  description: string
  gatewayKey: string // public key(desensitized)
  gatewaySecret: string // private key(desensitized)
  gatewayName: string // e.g., stripe.
  displayName: string // e.g., Bank Cards
  gatewayLogo: string
  gatewayIcons: string[]
  gatewayType: number
  gatewayWebsiteLink: string
  webhookEndpointUrl: string
  gatewayWebhookIntegrationLink: string
  webhookSecret: string // this is the public key(generated by Changelly), used to ensure the sender can be trusted
  createTime: number
  currencyExchangeEnabled: boolean // some gateways like Unitpay required exchange rate setting, like 1 euro = 102 Russian Rubles, 1$ = 98.027243 Russian Rubles
  currencyExchange: TGatewayExRate[] // exchange_rate == 0 means: BE'd go to https://app.exchangerate-api.com/ to get exchange rate.
  minimumAmount: number // wire transfer only
  currency: string // ditto
  bank?: {
    // ditto
    accountHolder: string
    bic: string
    iban: string
    address: string
  }
  sort: number
}

type TMerchantInfo = {
  id: number
  address: string
  companyId: string
  companyLogo: string
  companyName: string
  host: string
  email: string
  location: string
  phone: string
}

interface IAppConfig {
  env: string
  isProd: boolean
  supportTimeZone: string[]
  supportCurrency: { Currency: string; Symbol: string; Scale: number }[]
  gateway: TGateway[]
}

type Country = {
  countryCode: string
  countryName: string
}

interface IAddon extends IPlan {
  quantity: number | null
  checked: boolean
}

interface IProduct {
  id: number
  productName: string
  description: string
  status: number // ，1-active，2-inactive, default active
  metaData: string // json string
  createTime: number
  isDeleted: number
}

export enum PlanStatus {
  EDITING = 1,
  ACTIVE = 2,
  INACTIVE = 3,
  SOFT_ARCHIVED = 4,
  HARD_ARCHIVED = 5
}
export enum PlanType {
  MAIN = 1,
  ADD_ON = 2, // must be used with MAIN, cannot be bought alone
  ONE_TIME_ADD_ON = 3 // can be bought alone, has no dependencies on anything
}
interface IPlan {
  id: number
  productId: number
  planName: string
  description: string
  type: PlanType
  currency: Currency
  intervalCount: number
  intervalUnit: 'day' | 'week' | 'month' | 'year' //string;
  amount: number
  status: PlanStatus
  addons?: IAddon[]
  onetimeAddons?: IAddon[]
  cancelAtTrialEnd: number
  trialAmount: number
  trialDemand: string
  trialDurationTime: number
  plan?: IPlan
}

export interface ISubAddon extends IPlan {
  // when update subscription plan, I need to know which addons users have selected,
  // then apply them on the plan
  quantity: number
  addonPlan?: IPlan
  addonPlanId: number
}

export enum SubscriptionStatus {
  // INITIATING = 0, // used when creating the sub, it only exist for a very short time, user might not realize it existed
  PENDING = 1, // when sub is created, but user hasn't paid yet.
  ACTIVE = 2, // 2: active: user paid the sub fee
  // PendingInActive = 3, // when status is transitioning from 1 to 2, or 2 to 4, there is a pending status, it's not synchronous
  // so we have to wait, in status 3: no action can be taken on UI.
  CANCELLED = 4, // users(or admin) cancelled the sub(immediately or automatically at the end of billing cycle). It's triggered by human.
  EXPIRED = 5,
  // SUSPENDED = 6, // suspend for a while, might want to resume later. NOT USED YET.
  INCOMPLETE = 7, // user claimed they have wired the transfer, admin mark the subscription as Incomplete until a DATE, so user can use it before that DATE.
  // if admin had confirmed the transfer, admin has to mark the corresponding invoice as PAID, then this sub will become ACTIVE.
  PROCESSING = 8, // user claimed they have wired the transfer, but we're checking. This status is for wire-transfer only.
  FAILED = 9 // we have't received the payment.
}
interface ISubscription {
  subscription: ISubscription
  id: number
  subscriptionId: string
  planId: number
  productId: number
  userId: number
  status: SubscriptionStatus
  link: string | undefined
  firstPaidTime: number
  currentPeriodStart: number
  currentPeriodEnd: number
  defaultPaymentMethodId: string
  trialEnd: number
  cancelAtPeriodEnd: number // whether this sub will end at the end of billing cycle, 0: false, 1: true
  amount: number
  currency: string
  taxPercentage: number // 20000 means 20%
  plan: IPlan
  addons: ISubAddon[]
  user: IProfile | null
  unfinishedSubscriptionPendingUpdate?: {
    // downgrading will be effective on the next cycle, this props show this pending stat
    effectImmediate: number
    effectTime: number
    prorationAmount: number // for plan upgrading, you need to pay the difference amt.
    paid: number // 1: paid,
    link: string // stripe payment link
    plan: IPlan // original plan
    updatePlan: IPlan // plan after change(upgrade/downgrade, or quantity change)
    // these are pending subscription's actual data
    updateAmount: number
    updateCurrency: string
    updateAddons: ISubAddon[]
  }
  gatewayId: number
  latestInvoice?: UserInvoice
}

interface ISubHistoryItem {
  merchantId: number
  userId: number
  subscriptionId: string
  periodStart: number
  periodEnd: number
  invoiceId: string
  uniqueId: string
  currency: string
  planId: number
  plan: IPlan
  quantity: number
  addons: IAddon[]
  gatewayId: number
  createTime: number
}

interface IOneTimeHistoryItem {
  id: number
  bizType: number
  merchantId: number
  userId: number
  subscriptionId: string
  invoiceId: string
  uniqueId: string
  currency: string
  amount: number
  unitAmount: number
  quantity: number
  paymentId: string
  status: number
  createTime: number
  description: string
  name: string
}

export enum RefundStatus {
  AWAITING_REFUND = 10,
  REFUNDED = 20,
  FAILED = 30,
  CANCELLED = 40
}
type TRefund = {
  currency: string
  refundAmount: number
  refundComment: string
  refundTime: number
  createTime: number
  status: RefundStatus
  gatewayId: number
  paymentId: string
}
export enum CreditTxType {
  TOP_UP = 1,
  CONSUMPTION = 2,
  REFUND_TOP_UP = 3,
  WITHDRAWN = 4,
  WITHDRAWN_FAILED = 5,
  ADMIN_UPDATE = 6,
  RECHARGE_REFUND_OUT = 7
}
export type TCreditTx = {
  id: number
  user: IProfile
  creditAccount: TPromoAccount
  accountType: CreditType
  currency: string
  transactionId: string
  transactionType: CreditTxType
  creditAmountAfter: number
  creditAmountBefore: number
  deltaAmount: number
  deltaCurrencyAmount: number
  bizId: string
  name: string
  description: string
  createTime: number
  merchantId: number
  invoiceId: string
}
// this is for user view only, generated by admin or system automatically
interface UserInvoice {
  id: number
  merchantId: number
  userId: number
  subscriptionId: string
  invoiceId: string
  invoiceName: string
  gatewayInvoiceId: string
  uniqueId: string
  createTime: number
  originAmount?: number
  discountAmount?: number
  discount?: DiscountCode
  promoCreditDiscountAmount: number
  promoCreditTransaction?: TCreditTx
  totalAmount: number
  taxAmount: number
  taxScale: number
  subscriptionAmount: number
  currency: string
  lines: InvoiceItem[]
  status: number // go check INVOICE_STATUS in constants.ts
  sendStatus: number
  sendEmail: string
  sendPdf: string
  data: string
  isDeleted: number
  link: string
  gateway: TGateway
  gatewayId: number
  gatewayStatus: string
  gatewayPaymentId: string
  gatewayUserId: string
  gatewayInvoicePdf: string
  taxPercentage: number
  sendNote: string
  sendTerms: string
  totalAmountExcludingTax: number
  subscriptionAmountExcludingTax: number
  periodStart: number
  periodEnd: number
  paymentId: string
  refundId: string
  refund?: TRefund //

  userAccount: IProfile
}

type InvoiceItem = {
  id: string
  amount: number
  amountExcludingTax: number
  currency: string
  description: string
  periodEnd?: number
  periodStart?: number
  proration?: boolean
  quantity: number
  tax: number // tax amount
  taxPercentage: number // tax rate
  unitAmountExcludingTax: number
  discountAmount: number
  originAmount: number
}

type InvoiceItemTotal = {
  currency: string
  subscriptionAmount: number
  subscriptionAmountExcludingTax: number
  discountAmount: number
  taxAmount: number
  taxPercentage: number
  totalAmount: number
  totalAmountExcludingTax: number
  promoCreditAccount: TPromoAccount | null // null when promoCredit not used
  promoCreditDiscountAmount: number // 0 when not promoCredit not used
  promoCreditPayout: {
    creditAmount: number
    currencyAmount: number
    exchangeRate: number
  } | null // null when promoCredit not used
  lines: InvoiceItem[]
}

type PaymentItem = {
  id: number
  transactionId: string
  externalTransactionId: string
  merchantId: number
  userId: number
  subscriptionId: string
  invoiceId: string
  currency: string
  totalAmount: number
  gatewayId: number
  paymentId: string
  refund?: TRefund
  status: number
  timelineType: number
  createTime: number
}
export enum DiscountType {
  PERCENTAGE = 1,
  AMOUNT
}
export enum DiscountCodeStatus {
  EDITING = 1,
  ACTIVE = 2,
  INACTIVE = 3,
  EXPIRED = 4,
  ARCHIVED = 10
}
export enum DiscountCodeBillingType {
  ONE_TIME = 1,
  RECURRING = 2
}
type DiscountCode = {
  id?: number
  merchantId: number
  name: string
  code: string
  status?: DiscountCodeStatus
  billingType: DiscountCodeBillingType
  discountType: DiscountType
  discountAmount: number
  discountPercentage: number
  currency: string
  cycleLimit: number
  startTime: number
  endTime: number
  validityRange: [Dayjs | null, Dayjs | null]
  createTime?: number
  metadata?: {
    [key: string]: string
  }
}

interface IPreview {
  originAmount: number // total amt is the one after applying the discount code, this is the amt before discount
  totalAmount: number // these 3 fields need to be resent to backend when submitting createSub/updateSub
  prorationDate?: number // ditto
  currency: string // ditto
  discount: DiscountCode | null
  discountAmount: number
  discountMessage: string
  taxPercentage: number
  vatCountryCode?: string
  vatCountryName?: string
  vatNumber?: string
  vatNumberValidate?: {
    valid: boolean
    vatNumber: string
    countryCode: string
    companyName: string
    companyAddress: string
    validateMessage: string
  }
  vatNumberValidateMessage: string
  invoice: InvoiceItemTotal
  nextPeriodInvoice?: InvoiceItemTotal // same as above invoice obj, only optional, used when downgrading.
}

export class ExpiredError extends Error {
  constructor(m: string) {
    super(m)
  }
}

export type {
  Country,
  DiscountCode,
  IAppConfig,
  InvoiceItem,
  InvoiceItemTotal,
  IOneTimeHistoryItem,
  IPlan,
  IPreview,
  IProduct,
  IProfile,
  ISubHistoryItem,
  ISubscription,
  PaymentItem,
  TMerchantInfo,
  TRefund,
  UserInvoice
}
